# generated by datamodel-codegen:
#   timestamp: 2022-06-20T16:56:19+00:00


from __future__ import annotations

from contextlib import contextmanager
from pathlib import Path

import tuuid

from melanie import BaseModel, Field

CONVERSION_PATH = Path("/cache/tiktok_conv/")


@contextmanager
def borrow_temp_file(input_path_or_bytes: bytes | None = None, extension: str = "mp4") -> Path:
    if input_path_or_bytes:
        if isinstance(input_path_or_bytes, bytes):
            temp = CONVERSION_PATH / f"{tuuid.tuuid()}.{extension}"
            temp.write_bytes(input_path_or_bytes)
        else:
            temp = Path(str(input_path_or_bytes))
    else:
        temp = CONVERSION_PATH / f"{tuuid.tuuid()}.{extension}"
    try:
        yield temp
    finally:
        temp.unlink(missing_ok=True)


class Disposition(BaseModel):
    default: int | None
    dub: int | None
    original: int | None
    comment: int | None
    lyrics: int | None
    karaoke: int | None
    forced: int | None
    hearing_impaired: int | None
    visual_impaired: int | None
    clean_effects: int | None
    attached_pic: int | None
    timed_thumbnails: int | None
    captions: int | None
    descriptions: int | None
    metadata: int | None
    dependent: int | None
    still_image: int | None


class Tags(BaseModel):
    creation_time: str | None
    language: str | None
    handler_name: str | None
    vendor_id: str | None
    encoder: str | None


class Stream(BaseModel):
    index: int | None
    codec_name: str | None
    codec_long_name: str | None
    profile: str | None
    codec_type: str | None
    codec_tag_string: str | None
    codec_tag: str | None
    width: int | None
    height: int | None
    coded_width: int | None
    coded_height: int | None
    closed_captions: int | None
    film_grain: int | None
    has_b_frames: int | None
    pix_fmt: str | None
    level: int | None
    color_range: str | None
    color_space: str | None
    color_transfer: str | None
    color_primaries: str | None
    chroma_location: str | None
    refs: int | None
    id: str | None
    r_frame_rate: str | None
    avg_frame_rate: str | None
    time_base: str | None
    start_pts: int | None
    start_time: str | None
    duration_ts: int | None
    duration: str | None
    bit_rate: str | None
    nb_frames: str | None
    extradata_size: int | None
    disposition: Disposition | None
    tags: Tags | None
    sample_fmt: str | None
    sample_rate: str | None
    channels: int | None
    channel_layout: str | None
    bits_per_sample: int | None


class Tags1(BaseModel):
    minor_version: str | None
    compatible_brands: str | None
    te_is_reencode: str | None
    hw: str | None = Field(None, alias="Hw")
    bit_rate: str | None = Field(None, alias="bitRate")
    com_apple_quicktime_copyright: str | None = Field(None, alias="com.apple.quicktime.copyright")
    major_brand: str | None
    maxrate: str | None
    source: str | None
    creation_time: str | None
    encoder: str | None


class Format(BaseModel):
    filename: str | None
    nb_streams: int | None
    nb_programs: int | None
    format_name: str | None
    format_long_name: str | None
    start_time: str | None
    duration: str | None
    size: str | None
    bit_rate: str | None
    probe_score: int | None
    tags: Tags1 | None


class FFProbeData(BaseModel):
    streams: list[Stream] | None
    format: Format | None

    @property
    def video_stream(self) -> Stream:
        return next(x for x in self.streams if x.codec_type == "video")

    @property
    def is_h264(self) -> bool:
        return self.video_stream.codec_name == "h264"
